include "src/hardware.inc"
include "src/global.inc"

section "COINS", ROM0, ALIGN[2]

coin_list::
  ; stage 1
  dw coin_add_hl_flags, coin_add_sp_flags, coin_apu_off_ignore_writes, coin_apu_or_mask, coin_apu_sweep_status
  dw coin_apu_len_env00_status, coin_div_increases, coin_lyc_to_hint, coin_start_timer, coin_no10
  ; stage 2
  dw coin_ei_if_write, coin_di_halt_sets_if, coin_di_halt_2inc, coin_di_halt_no_handler, coin_daa_no_h
  dw coin_no16, coin_apu_off_clear, coin_apu_status_ro, coin_push_af_low_4, coin_oam_bug
  ; stage 3



section "STAGE1COINS", ROM0

; Each coin is a subroutine then a description.
; The subroutine returns carry clear for pass or set for fail

test_failed:
  scf
  ret

coin_add_hl_flags:
  jr .start
  db "add hl flags",10
  db "add hl,de; add hl,sp",10
  db "Z same, N=0, HC=carry",10
  db "from bits 11 and 15",0
.start:
  ld de, $8800
  push de
  pop af  ; Clear ZNHC

  ld hl, $7800
  add hl, de  ; Set HC
  push af
  pop bc
  ld a, c
  cp $30
  jr nz, .local_test_failed

  and a  ; Clear ZN, set H, clear C
  ld hl, $8700
  add hl, de  ; Clear NH, set C
  push af
  pop bc
  ld a, c
  cp $10
  jr nz, .local_test_failed

  sub a  ; Set ZN, clear H
  ld hl, $6800
  add hl, de  ; Clear N, set HC
  push af
  pop bc
  ld a, c
  cp $A0
  jr nz, .local_test_failed

  scf
  sbc a  ; Clear Z, set NHC
  ld hl, $7700
  add hl, de  ; Clear NHC
  push af
  pop bc
  ld a, c
  or a
.local_test_failed:
  jp nz, test_failed
  ret

coin_add_sp_flags:
  jr .start
  db "add sp flags",10
  db "add sp,rel; ld hl,sp+rel",10
  db "Z=N=0, HC=carry from",10
  db "bits 3 and 7 of unsigned",10
  db "add to SP low byte",0
.start:
  ld hl, sp+0
  ld sp, $D000
  add sp, -2
  ld sp, hl  ; No way to set carry if SPL = $00
  push af
  pop bc
  ld a, c
  or a
  jp nz, test_failed
  ret

coin_apu_off_ignore_writes:
  jr .start
  db "APU off ignore writes",10
  db "FF10-FF25 writes not",10
  db "honored while APU off, nor",10
  db "revealed when turned on",0
.start:
  call zerofill_apu
  xor a
  ldh [rNR52], a  ; APU is off

  ; Write test pattern
  ld a, $02
  ldh [rNR12], a
  add a
  ldh [rNR22], a
  add a
  ldh [rNR42], a
  add a
  ldh [rNR43], a
  add a
  ldh [rNR51], a
  add a
  ldh [rNR50], a

  call .read_test_pattern
  jr nz, .local_test_failed
  ld a, $80
  ldh [rNR52], a
  call .read_test_pattern
.local_test_failed:
  jp nz, test_failed
  ldh [rNR52], a
  ret

.read_test_pattern:
  ld hl, rNR12
  ld a, [hl]
  ld l, low(rNR22)
  or [hl]
  ld l, low(rNR42)
  or [hl]
  ld l, low(rNR43)
  or [hl]
  ld l, low(rNR51)
  or [hl]
  ld l, low(rNR50)
  or [hl]
  ret


apu_or_mask_values:
  db $80,$3F,$00,$FF,$BF
  db $FF,$3F,$00,$FF,$BF
  db $7F,$FF,$9F,$FF,$BF
  db $FF,$FF,$00,$00,$BF
  db $00,$00 ;,$70
apu_or_mask_values_end:

;;
; Turns on the APU and writes $00 to all registers.
; @return A=C=0, HL=NR52
zerofill_apu:
  ; Power cycle the APU for good measure
  ld hl, rNR52
  xor a
  ld [hl], a
  ld [hl], $80

  ; Zero fill APU registers other than power
  ld c, apu_or_mask_values_end-apu_or_mask_values
  ld hl, rNR10
  jp memset_tiny

coin_apu_or_mask:
  jr .start
  db "APU OR mask",10
  db "When APU filled with 0 bytes,",10
  db "unused bits read back 1",0
.start:
  call zerofill_apu

pass_if_apu_equals_or_mask:
  ; Values in APU must equal OR mask
  lb bc, apu_or_mask_values_end-apu_or_mask_values, low(rNR10)
  ld hl, apu_or_mask_values
  .compareloop:
    ld a, [$FF00+c]
    cp [hl]  ; last thing that touches the carry.  Z after CP means NC.
    jp nz, test_failed
    inc hl
    inc c
    dec b
    jr nz, .compareloop
  ret

coin_apu_sweep_status:
  jr .start
  db "APU sweep status",10
  db "Upward sweep on pulse 1",10
  db "clears channel status;",10
  db "downward sweep doesn't",0
.start:
  call init_silent_apu
  di

  ld a, $25
  ld bc, $8787
  call play_sweep_note
  ld a, d
  or a
  jp z, test_failed

  ld a, $1A
  ld bc, $8300
  call play_sweep_note
  ld a, d
  or a
  jp nz, test_failed
  ret

;;
; Turn on the APU; just don't route any channels to any speakers
init_silent_apu:
  ld hl, rNR52
  xor a
  ld [hl], a
  ld [hl], $80
  dec l
;  ld a, $77  ; uncomment this to debug APU tests
  ld [hl-], a
  ld [hl], a
  ret

play_sweep_note:
  ld hl, rNR10
  ld [hl+], a  ; sweep direction
  ld a, $80
  ld [hl+], a  ; duty and length counter
  ld [hl+], a  ; envelope
  ld [hl], c
  inc l
  ld [hl], b
  ; fall through to time_pulse1_note

time_pulse1_note:
  ; Give a sweep 1/8 second cycles to ring out
  ld hl, rNR52
  ld de, -96768/9
  .waitloop:
    bit 0, [hl]
    ret z
    inc e
    jr nz, .waitloop
    inc d
    jr nz, .waitloop
  ret

play_pulse1_envb_lenc:
  ld hl, rNR10
  xor a
  ld [hl+], a
  ld [hl], c
  inc l
  ld [hl], b
  inc l
  ld [hl+], a
  ld [hl], $C7
  jr time_pulse1_note

coin_apu_len_env00_status:
  jr .start
  db "APU length & envelope 00",10
  db "Length counter expiry or",10
  db "envelope set to 0 clears",10
  db "channel status",0
.start:
  call init_silent_apu
  di
  lb bc, $80, $80  ; control arm
  call play_pulse1_envb_lenc
  ld a, d
  or a
  jp nz, test_failed
  lb bc, $80, $7C  ; experiment arm: length counter
  call play_pulse1_envb_lenc
  ld a, d
  or a
  jp z, test_failed
  lb bc, $00, $80  ; experiment arm: 0 envelope
  call play_pulse1_envb_lenc
  ld a, d
  or a
  jp z, test_failed
  ret

coin_div_increases:
  jr .start
  db "DIV increases",10
  db "FF04 timer increases",10
  db "by 1 unit per period",0
.start:
  ld d, 10  ; number of trials
  ld hl, rDIV
  .trialloop:
    ld e, 10  ; timeout loop for this trial
    ld c, [hl]
    .timeoutloop:
      ld a, [hl]
      sub c
      jr nz, .trialdone
      dec e
      jr nz, .timeoutloop
    .trialdone:
    cp 1
    jp nz, test_failed
    dec d
    jr nz, .trialloop
  ret

coin_lyc_to_hint:
  jr .start
  db "Getting the hint",10
  db "Schedule LYC interrupt at",10
  db "FF41, then horizontal blank",10
  db "interrupt on same line",0
.start:
  call lcd_on_blank
  call measure_mode3
  push af
  call lcd_off
  pop af
  cp 4  ; If A < 4 then there was only one interrupt
  ret

lcd_on_blank:
  call lcd_off
  ld a, 64
  ldh [rLYC], a
  xor a
  ldh [rSCX], a
  ldh [rBGP], a    ; hide everything during test
  ld hl, $FE00     ; clear ALL of OAM to 0
  ld c, $A0
  call memset_tiny
  inc a
  ldh [rIE], a
  ld a, LCDCF_ON|LCDCF_BGON|LCDCF_WINON|LCDCF_OBJON|LCDCF_BG8800|LCDCF_BG9800|LCDCF_WIN9C00
  ldh [rLCDC], a
  ret


IEB_TIMER = 2

;;
; Analogous to the "does the timer even work?" check from blargg's
; instr_timing test, adding a timeout on the start_timer part
coin_start_timer:
  jr .start
  db "Four-cycle timer",10
  db "FF07=5,FF05=-20 sets FF0F",10
  db "timer bit after 80 cycles;",10
  db "can write 0 to FF05 and",10
  db "read 0 after 3 cycles",0
.start:
  ; 1. Set up the timer
  di
  ld hl, rIE
  res IEB_TIMER, [hl]  ; keep VBA from calling handlers despite DI
  ld l, low(rIF)
  ld a, 5
  ldh [rTAC], a  ; four mcycles per increment, 262 kHz
  xor a
  ldh [rTMA], a  ; set reload value for full range
  ld [hl], a     ; ack all interrupts (everywhere but rew.)

  ; 2. Ensure the timer increases from -20 to 0 in 80 cycles
  ld a, 256-20
  ldh [rTIMA], a
  ld b, 20-2
  ; This delay loop triggers a heisenbug in NO$GMB:
  ; IF.2 gets set if and only if not step debugging
  .delayloop1:
    dec b
    jr nz, .delayloop1
  bit IEB_TIMER, [hl]
  jr nz, sync_to_TIMA.fail
  bit IEB_TIMER, [hl]
  jr z, sync_to_TIMA.fail
  ; If we've reached here in NO$GMB then step debugging was off.
  ; Fall through to the test

  ; 3. Align to 4-cycle timer by looping while [. . W .|. R . .] for
  ; an odd number of cycles until we hit [W . . R]
  ; (NO$GMB has failed this one in the past)
sync_to_TIMA:
  ld b, 4
.loopfifteen:
  xor a           ; 1
  ldh [rTIMA], a  ; 3 write on cycle N
  ldh a, [rTIMA]  ; 3 read on cycle N+3
  or a            ; 1
  ret z           ; 2
  nop             ; 1
  dec b           ; 1
  jr nz, .loopfifteen  ; 3
.fail:
  scf
  ret

; We assume we can read and write in mode 1. Lots of games
; don't work otherwise.
; 
; The only emulator I'm aware of that doesn't make mode 1 wide open
; is one that ISSOtm mentioned:
; the Game Boy emulator in PokÃ©mon Stadium 2 Game Boy Tower.
; Only the vblank handler can access VRAM.  Once it does RETI,
; VRAM is locked even if mode 1 is still in effect.
coin_no10:
  jr .start
  db "VRAM/OAM blocked writes",10
  db "VRAM and OAM are",10
  db "inaccessible in mode 3.",10
  db "OAM inaccessible in mode 2.",0
.start:
  call lcd_on_blank

  ; Write to video memory (expect lots of invalid
  ld hl, $9F00
  call write_in_all_modes
  ld hl, $FE80
  call write_in_all_modes

  ; Read back
  ld hl, $9F00
  call write_in_all_modes_readback
;  ld [debughex+0], a
  cp %00010100  ; VRAM: mode 3 blocked
  jr nz, .local_failed
  ld hl, $FE80
  call write_in_all_modes_readback
;  ld [debughex+1], a
  ; On Game Boy, Super Game Boy, and Game Boy pocket, the (invalid)
  ; writes to OAM mess up the previous valid writes.  This looks
  ; like it could be the OAM bug.  Until I understand the OAM bug
  ; in more detail, I'll disregard the affected writes for now.
  and %00111111  ; disregard writes affected by OAM bug
  cp %00111100  ; OAM: modes 2 and 3 blocked
  jr nz, .local_failed
  call lcd_off
  or a
  ret
.local_failed:
  call lcd_off
  scf
  ret

write_in_all_modes:
  lb de, "0", 0
  call write_in_mode_E
  lb de, "1", 1
  call write_in_mode_E
  lb de, "2", 2
  call write_in_mode_E
  lb de, "3", 3
  call write_in_mode_E
  lb de, "O", 2
  call write_in_mode_E
  lb de, "P", 3
  call write_in_mode_E
  lb de, "H", 0
  call write_in_mode_E
  lb de, "V", 1
  ; fall through
;;
; @param D byte to write
; @param E mode to write in
write_in_mode_E:
  lb bc, 3, low(rSTAT)
  .wait0loop:
    ld a, [$FF00+c]
    xor e
    and b
    jr z, .wait0loop
  .wait1loop:
    ld a, [$FF00+c]
    xor e
    and b
    jr nz, .wait1loop
  ld [hl], d
  ld a, d
  cpl
  inc l
  ld [hl], a
  inc l
  ret

write_in_all_modes_readback:
  push hl
  ei
  call wait_vblank_irq
  pop hl
  ld b, 1
  .loop:
    ld a, [hl+]
    xor [hl]
    inc l
    cp $FF
    rl b
    jr nc, .loop
  ld a, b
  ret


; mode 3 duration measurement ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; This kernel will be used by multiple coins to measure the effect of
; sprite positions, SCX&7, and WX&7 on duration of mode 3.

section "measure_mode3", ROM0

measure_mode3:
  ; Allow only IRQs on the chosen scanline to cause an interrupt
  ld c, low(rSTAT)
  ld a, STATF_LYC
  ld [$FF00+C], a
  ld a, [rIE]
  push af
  ld a, IEF_LCDC
  ldh [rIE], a

  ; rew. doesn't respond to IF writes, and VBA behaves badly with
  ; di halt).  So drain out pending interrupts while preparing for
  ; the steps to come.
  ei
  ld a, STATF_MODE00
  ld hl, sp+-2

  ; At the start of mode 2 on the chosen line, the CPU calls the STAT
  ; interrupt handler, which happens to take as long as mode 2.
  ; This leaves us at the start of mode 3.  Include the halt in the
  ; length calculation to compensate for it taking an extra cycle
  ; to schedule the hblank interrupt.
.nopslide_start:
  halt

  rept 3
    nop
  endr

  ; Schedule another interrupt at the end of drawing.
  ; Caution: On DMG, writing to STAT writes FF then the value.
  ; This causes an extra interrupt during mode 3 outside line LYC,
  ; on which Road Rash (DMG version) and Xerd no Densetsu depend.
  ; But because we're in LYC, we're safe.
  ld [$FF00+C], a

  ; now we are in mode 2 and measuring the remainder of mode 2
  ; plus all of mode 3
  rept 75
    nop
  endr

  pop af
  ldh [rIE], a  ; Restore previous interrupt setting
  ld a, [hl]    ; Read progress into slide from stack red zone
  sub low(.nopslide_start)
  ret

; Stage 2 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

section "STAGE2COINS", ROM0

coin_ei_if_write:
  jr .start
  db "IF write causes IRQ",10
  db "With interrupts on, writing",10
  db "to pending interrupts register",10
  db "calls handler",0
.start:
  di
  xor a
  ldh [rTAC], a    ; Disable timer so that only fake interrupt happens
  ld bc, rIF
  ld [bc], a       ; Acknowledge all interrupts
  ld a, IEF_TIMER
  ldh [rIE], a     ; Allow only timer interrupts
  ld hl, sp-1      ; Get a pointer to the stack red zone
  ei
  push bc
  pop bc           ; Place IF address in the red zone
  ldh [$FF00+c], a ; Trigger an interrupt, overwriting the red zone
.return_addy:      ; with this return address
  ld a, [hl-]      ; the return address should match 
  cp high(.return_addy)
  jp nz, test_failed
  ret

coin_di_halt_sets_if:
  jr .start
  db "di halt sets IF bit",10
  db "Halting with interrupts off",10
  db "sets a bit in the pending",10
  db "interrupts register",0
.start:
  di
  xor a
  ldh [rIF], a
  ld a, IEF_TIMER
  ldh [rIE], a     ; Listen only to timer interrupts
  ld a, 7
  ldh [rTAC], a    ; Enable timer
  halt
  nop
  ldh a, [rIF]
  and IEF_TIMER    ; Make sure a timer interrupt arrived
  jp z, test_failed
  ret

coin_di_halt_2inc:
  jr .start
  db "di halt double increment",10
  db "Halting with interrupts off",10
  db "and a pending interrupt",10
  db "runs the next byte twice",0
.start:
  di
  call schedule_timer_interrupt
  ld de, 0
  halt
  inc d  ; Increment D once
  halt
  inc e  ; Increment E, twice
  ld a, d
  dec a
  jp nz, test_failed
  ld a, e
  cp 2
  jp nz, test_failed
  ret

coin_di_halt_no_handler:
  jr .start
  db "di halt calls no handler",10
  db "Halting with interrupts off",10
  db "does not call the interrupt",10
  db "handler",0
.start:
  di
  call schedule_timer_interrupt
  ld bc, rIF
  push bc          ; Clear the stack red zone
  pop bc
  halt
  nop
  ld hl, sp-1      ; Get a pointer to the stack red zone
  ld a, [hl-]      ; The value of B should still be there
  cp b
  jp nz, test_failed
  ret

schedule_timer_interrupt:
  ld a, 5
  ldh [rTAC], a    ; Enable timer
  xor a
  ldh [rTIMA], a   ; Schedule timer
  ldh [rTMA], a
  ldh [rIF], a     ; Acknowledge all interrupts
  ld a, IEF_TIMER
  ldh [rIE], a     ; Now listen for interrupts
  ret

coin_daa_no_h:
  jr .start
  db "daa clears half carry",10
  db "ld a,5 add a daa = $10",10
  db "ld a,9 add a daa = $18",10
  db "H is clear after each",0
.start:
  ld a, $05
  ld b, $10
  call add_a_daa_eq_b_no_h
  ret c
  ld a, $09
  ld b, $18
add_a_daa_eq_b_no_h:
  add a
  daa
  push af
  pop de
  cp b
  jr nz, .local_test_failed
  bit 5, e
.local_test_failed:
  jp nz, test_failed
  ret

coin_no16:
  jr .start
  db "Coin #16",10
  db "Always pass for now",0
.start:
  or a
  ret

coin_apu_off_clear:
  jr .start
  db "What APU off clears",10
  db "Turning APU off clears",10
  db "readable sound registers",10
  db "and not wave RAM",0
.start:
  ; Turn on the APU, fill with $FF
  ld a, $FF
  ldh [rNR52], a
  ld c, apu_or_mask_values_end-apu_or_mask_values
  ld hl, rNR10
  call memset_tiny
  call set_wave_ram_signature

  ; Turn off the PPU and OR mask must be read back
  xor a
  ldh [rNR52], a
  call pass_if_apu_equals_or_mask
  ret c
  call compare_wave_ram_signature  ; bgb fails here
  ret c

  ; Turn the APU on and see if it still reads 0
  ld a, $80
  ldh [rNR52], a
  call pass_if_apu_equals_or_mask
  ; Fall through to pass if wave RAM holds correct data

compare_wave_ram_signature:
  ldh a, [_AUD3WAVERAM+14]
  cp $0C
  jr nz, .local_test_failed
  ldh a, [_AUD3WAVERAM+15]
  cp $A5
.local_test_failed:
  jp nz, test_failed
  ret

set_wave_ram_signature:
  ld a, $0C
  ldh [rNR30], a  ; ensure wave is stopped
  ldh [_AUD3WAVERAM+14], a
  ld a, $A5
  ldh [_AUD3WAVERAM+15], a
  ret

coin_apu_status_ro:
  jr .start
  db "APU status read-only",10
  db "Writes to bits 6-0 of FF26",10
  db "are not read back",0
.start:
  ld hl, rNR52
  ld [hl], 0
  ld a, $70
  cp [hl]
  jr nz, .local_test_failed
  ld a, $F0
  ld [hl], $FF  ; should read $70
  cp [hl]
.local_test_failed:
  jp nz, test_failed
  ret

coin_push_af_low_4:
  jr .start
  db "flags low nibble",10
  db "push bc pop af",10
  db "  push af pop de",10
  db "Pushes flags bit 3-0 as 0",0
.start:
  ld bc, $0CA5
  push bc
  pop af
  push af
  pop de

  ld a, b
  cp d
  jp nz, test_failed
  ld a, c
  and $F0
  cp e
  jp nz, test_failed
  ret

coin_oam_bug:
  jr .start
  db "NYA 16-bit inc corrupts OAM",10
  db "With H=FE, inc hl in mode 2",10
  db "corrupts OAM on B&W system",0
.start:
  or a
  ret

; Stage 3 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

section "STAGE3COINS", ROM0

; This is the first test I want to make with different behavior
; on Game Boy and Game Boy Color
coin_gbc_palette_readback:
  jr .start
  db "GBC palette reading in vblank",10
  db "",10
  db "",0
.start:
  or a
  ret

coin_wave_ram_locked:
  jr .start
  db "Wave RAM locked while playing",10
  db "During a wave note, wave RAM",10
  db "reads as the byte at the",10
  db "play pointer or $FF",10
  db 34,"NO BOY! NO DEMO!",34,0
.start:
  or a
  ret

