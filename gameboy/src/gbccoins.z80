include "src/hardware.inc"
include "src/global.inc"

def vCoinTmp equ $9FFF

; Stage 4: Game Boy Color ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

section "STAGE4COINS", ROM0

coin_no_31::
  jr .start
  db "Always pass for now",0
.start:
  or a
  ret

coin_no_32::
  jr .start
  db "Always pass for now",0
.start:
  or a
  ret

coin_stat_write_ff::
  jr .start
  db "NYA STAT briefly enables all",10
  db "Writing 0 to FF41 in mode",10
  db "0-2 or LY=LYC fires",10
  db "interrupt on B&W only",10
  db "'Road Rash? More like crash!'",0
.start:
  or a
  ret

coin_ram_capacity::
  jr .start
  db "RAM capacity",10
  db "B&W: 8K WRAM 8K VRAM",10
  db "GBC: 32K WRAM 16K VRAM",10
  db "(and Dxxx bank 0 is 1)",0
.start:

  call lcd_off
  ldh a, [hCapability]
  and $80
  rlca
  ld d, a  ; D is $01 for GBC/GBA or $00 for DMG/SGB

  ; Fill sentinel bytes of RAM with bank number
  xor a
  .fill_banks:
    ldh [rSVBK], a
    ld [wxCoinTmp], a  ; write 00 FF FE FD ... 02 01 to WRAMX
    dec a
    ldh [rSVBK], a
    ldh [rVBK], a
    ld [wCoinTmp], a   ; write FF FE FD FC ... 01 00 to WRAM0
    ld [vCoinTmp], a   ; write FF FE FD FC ... 01 00 to VRAM
    jr nz, .fill_banks

  ; Test that each byte has the expected value
  .test_banks:
    ldh [rSVBK], a
    ldh [rVBK], a
    ld b, a  ; B: current bank number

    ; VRAM bank should be current_bank & is_GBC
    and d
    ld hl, vCoinTmp
    xor [hl]  ; Should be 0
    ; WRAM0 bank should always be 0
    ld hl, wCoinTmp
    or [hl]  ; Should be 0
    jr nz, .fail

    ; WRAMX bank should be 1 if is_GBC == 0 or (bank & $07) == 0
    ; or bank & $07 otherwise
    or d
    jr z, .force_bank_1
      ld a, b
      and $07
      jr nz, .have_expected_wramx_bank
    .force_bank_1:
      inc a
    .have_expected_wramx_bank:
    ld hl, wxCoinTmp
    xor [hl]  ; Should be 0
    jr nz, .fail

    ld a, b
    dec a
    jr nz, .test_banks

  jr .pass
.fail:
  xor a
  scf
.pass:
  ldh [rSVBK], a
  ldh [rVBK], a
  ret

coin_gbc_or_mask::
  jr .start
  db "NYA OR mask for GBC regs",10
  db "Unused bits of GBC-only",10
  db "registers read as 1;",10
  db "all $FF on B&W system",0
.start:
  or a
  ret


def DEBUGHEX_GBC_MODE_3_LENGTH equ 0

coin_gbc_mode_3_length::
  jr .start
  db "Spriteless mode 3 length",10
  db "Disabling objects in LCDC",10
  db "shortens mode 3 on B&W only",0
.start:
  call lcd_on_blank

  ; DMG treats LCDCF_OBJON false as all sprites out of range,
  ; leading to a short mode 3.
  ; GBC treats LCDCF_OBJON false as all transparent, leading to
  ; mode 3 as long as it was if LCDCF_OBJON were true.
  ld a, LCDCF_ON|LCDCF_BGON  ; no sprites!
  ldh [stat_lcdc_value], a
  ldh [vblank_lcdc_value], a
  lb bc, 10, 8
  call mode_3_test_with_full_load
  if DEBUGHEX_GBC_MODE_3_LENGTH
    ld [debughex+0], a
  endc
  cp 50    ; CF = 1 for short mode 3, 0 for long mode 3
  ccf
  rr b     ; bit 7 = 0 for short mode 3, 1 for long mode 3
  ld a, [hCapability]  ; bit 7 = 0 to expect short, 1 to expect long
  xor b    ; bit 7 = 0 for match, 1 for mismatch
  adc a    ; move to CF
  jp lcd_off_and_return

def WAVE_RAM_RETRIGGER_AUDIBLE equ 0
def DEBUGHEX_WAVE_RAM_RETRIGGER equ 0

coin_wave_ram_retrigger::
  jr .start
  db "Retrigger corrupts wave",10
  db "Playing a wave note without",10
  db "turning DAC off and on",10
  db "changes byte 0 on B&W only",0
.start:
  call init_silent_apu
  call load_sawtooth_wave  ; first byte is $00; rest is nonzero

  ld b, 256-64
  .period_loop:

    ; Play a high-pitched tone
    ld hl, rNR30
    if WAVE_RAM_RETRIGGER_AUDIBLE
      ld a, $A0
    else
      ld a, $80
    endc
    ld [hl+], a  ; enable DAC
    ld [hl+], a  ; length counter
    ld [hl+], a  ; volume
    ld [hl], b   ; initial period
    ld a, $87
    ldh [rNR34], a  ; trigger + high period
    ld [hl], $100-2  ; second period

    ; Wait a bit and retrigger it
    ld c, 40
    .cdloop:
      dec c
      jr nz, .cdloop
    ldh [rNR34], a  ; retrigger

    xor a
    ldh [rNR30], a  ; disable DAC
    inc b
    jr nz, .period_loop

  ; At this point, the first byte should have been overwritten
  ; several times on DMG or not at all on GBC.  Set B bit 7 to true
  ; if we expect it to still be 0.
  ldh a, [hCapability]
  ld b, a  ; bit 7 = 1 to expect zero or 0 to expect nonzero
  ldh a, [_AUD3WAVERAM]
  if DEBUGHEX_WAVE_RAM_RETRIGGER
    ld [debughex+0], a
  endc
  cp 1   ; CF = 1 if 0 or 0 if nonzero
  rra    ; move to bit 7
  xor b  ; bit 7 = 0 if match or 1 if wrong
  adc a  ; move to CF
  ret

coin_gbc_palette_readback::
  jr .start
  db "NYA GBC CRAM readable",10
  db "Can read palette during",10
  db "vblank on GBC only",0
.start:
  or a
  ret

coin_gbc_palette_blocking::
  jr .start
  db "NYA GBC CRAM blkd writes",10
  db "GBC CRAM is inaccessible",10
  db "in mode 3 (and never",10
  db "accessible on B&W)",0
.start:
  or a
  ret

coin_no_40::
  jr .start
  db "Always pass for now",0
.start:
  or a
  ret

